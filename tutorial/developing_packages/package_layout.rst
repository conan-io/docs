.. _conanfile_conan_package_layout:

Understanding the Conan Package layout
======================================

.. _developing_packages_layout:

In the last section, we introduced the concept of the :ref:`editable packages
<editable_packages>` and mentioned that the reason why packages work flawlesly when put in
editable mode is because of the current definition of the information in the ``layout()``
method. Let's see this feature in more detail.

In this tutorial we will continue working with the  ``say/1.0`` package  and the
``hello/1.0`` consumer used in the :ref:`editable packages <editable_packages>` tutorial.

Please, first of all, clone the sources to recreate this project. You can find them in the
`examples2.0 repository <https://github.com/conan-io/examples2>`_ in GitHub:

.. code-block:: bash

    $ git clone https://github.com/conan-io/examples2.git
    $ cd examples2/tutorial/developing_packages/package_layout


As you can see, the main folder structure is the same: 

..  code-block:: text

    .
    ├── hello
    │   ├── CMakeLists.txt
    │   ├── conanfile.py
    │   └── src
    │       └── hello.cpp
    └── say
        ├── CMakeLists.txt
        ├── conanfile.py
        ├── include
        │   └── say.h
        └── src
            └── say.cpp


The main difference here is that we are not using the predefined
:ref:`cmake_layout()<cmake_layout>` in the ``say/1.0`` ConanFile but we are declaring our
own custom layout. Let's see how we describe the information in the ``layout()`` method so
that it works when we create the package in the Conan local cache and also when we have
the package in editable mode:

..  code-block:: python
    :caption: say/conanfile.py

    import os
    from conan import ConanFile
    from conan.tools.cmake import CMake


    class SayConan(ConanFile):
        name = "say"
        version = "1.0"

        exports_sources = "CMakeLists.txt", "src/*", "include/*"

        ...

        def layout(self):

            ## define project folder structure

            self.folders.source = "."
            self.folders.build = os.path.join("build", str(self.settings.build_type))
            self.folders.generators = os.path.join(self.folders.build, "generators")

            ## cpp.package information is for consumers to find the package contents in the Conan cache

            self.cpp.package.libs = ["say"]
            self.cpp.package.includedirs = ["include"] # includedirs is already set to 'include' by
                                                       # default, but declared for completion
            self.cpp.package.libdirs = ["lib"]         # libdirs is already set to 'lib' by
                                                       # default, but declared for completion

            ## cpp.source and cpp.build information is specifically designed for editable packages:

            # this information is relative to the source folder that is '.'
            self.cpp.source.includedirs = ["include"] # maps to ./include

            # this information is relative to the build folder that is './build/<build_type>', so it will 
            self.cpp.build.libdirs = ["."]  # map to ./build/<build_type> for libdirs

        def build(self):
            cmake = CMake(self)
            cmake.configure()
            cmake.build()


Let's review the ``layout()`` method, you can see that we are setting values for
self.folders and self.cpp, let's explain what those are doing:

**self.folders** 

Defines the ``say`` project structure for the source code and also the folders where the
Conan generated files and build artifacts will be located, regardless of wether it is in
editable mode or exported and built in the Conan local cache. This should reflect the
folder structure of the project:

..  code-block:: text

     say
      ├── CMakeLists.txt
      ├── conanfile.py
      ├── include
      │   └── say.h
      └── src
          └── say.cpp

- As we have our ``CMakeLists.txt`` in the ``.`` folder, ``self.folders.source`` is set to
  "**.**".
- We set ``self.folders.build`` to be **./build/release** or **./build/debug** depending
  on the build_type.
- The ``self.folders.generators`` folder is where all files generated by Conan will be
  stored so they don’t pollute the other folders.

Please, note that the values above are for a single-configuration CMake generator. To
support multi-configuration generators, such as Visual Studio, you should make some
changes to this layout. For a complete layout that supports both single-config and
multi-config, please check the :ref:`cmake_layout()<cmake_layout>` in the Conan
documentation.

**self.cpp**

We can set the information about the package that the consumers need to use by setting
the conanfile’s ``cpp.package`` attributes values:

- Declaring ``self.cpp.package.libs`` inside the ``layout()`` method is equivalent to
    the “classic” ``self.cpp_info.libs`` declaration in the ``package_info()`` method.

- Also, as you may know, ``self.cpp.package.includedirs`` is set to ``["include"]`` by
    default, so there’s no need in declaring it but we are leaving it here for
    completeness.

We can also describe the ``source`` and ``build`` folders with the ``cpp.source`` and
``cpp.build`` objects with information that will be used for consumers of a package in
editable mode:

- We are setting ``self.cpp.source.includedirs = ["include"]``. The
    ``self.folders.source`` information will be automatically prepended to that path for
    consumers so, for example, when working with an editable package, Conan will try to
    get the include files from the **./my_project_folder/include** folder.
- We set the ``self.cpp.build.libdirs`` to **["."]**, so we are declaring that, if we
    make the package ``editable``, the libraries will be at the
    **./build/<build_type>** folder.

So, now we can run the conan local methods without taking much care of the directories where the
files are or the build files should be, because everything is declared in the layout:

.. code:: bash

    # This will write the toolchains and generator files from the dependencies to cmake-build-debug/generators
    $ conan install . -if=my_install -s build_type=Debug

    # In case we needed it (not the case as we don't have a source() method), this would fetch the sources to the ./src folder
    $ conan source . -if=my_install

    # This will build the project using the declared source folder and cmake-build-debug as the build folder
    $ conan build . -if=my_install


Our current folder now looks like this:

..  code-block:: text

    <my_project_folder>
    ├── conanfile.py
    ├── src
    │   ├── CMakeLists.txt
    │   ├── hello.cpp
    │   ├── my_tool.cpp
    │   └── include
    │       └── hello.h
    └── cmake-build-debug
        ├── libsay.a
        └── bin
            └── my_tool


We could put the package in editable mode and other packages that require it would consume it in a
completely transparent way, even locating the correct **Release**/**Debug** artifacts.

.. code:: bash

    $ conan editable add . say/0.1

.. note:: 

    When working with :ref:`editable packages<editable_packages>`, the information set in ``self.cpp.source`` and ``self.cpp.build`` will be merged with the
    information set in ``self.cpp.package`` so that we don't have to declare again something like ``self.cpp.build.libs = ["say"]`` that is
    the same for the consumers, independently of whether the package is in editable mode or not.
    ------>>> ADD A NOTE HERE TO TELL USERS TO ONLY DECLARE THE INFORMATION THAT IS DIFFERENT BETWEEN EDITABLE AND REGULAR PACKAGE


And of course, we can run also a ``conan create`` command. When the ``build(self)`` method is run in the conan cache, it is
also able to locate the ``my_tool`` correctly, because it is using the same ``folders.build``:


..  code-block:: text
     :caption: .conan2/p/<recipe_folder>
     :emphasize-lines: 9

     ├── source
     │   └── src
     │       ├── CMakeLists.txt
     │       ├── hello.cpp
     │       ├── my_tool.cpp
     │       └── include
     │           └── hello.h
     ├── build
     │   └── cmake-build-debug
     │       ├── say.a
     │       └── bin
     │           └── my_app
     └── package
         ├── lib
         │   └── say.a
         ├── bin
         │   └── my_app
         └── include
             └── hello.h


Example: export_sources_folder
-------------------------------

If we have this project, intended to create a package for a third-party library which code is located externally:

..  code-block:: text

    ├── conanfile.py
    ├── patches
    │   └── mypatch
    └── CMakeLists.txt


The ``conanfile.py`` would look like this:

..  code-block:: python

      import os
      from conan import ConanFile


      class Pkg(ConanFile):
          name = "pkg"
          version = "0.1"
          exports_sources = "CMakeLists.txt", "patches*"

          def layout(self):
              self.folders.source = "src"
          
          def source(self):
              # we are inside a "src" subfolder, as defined by layout
              # download something, that will be inside the "src" subfolder
              # access to patches and CMakeLists, to apply them, replace files is done with:
              mypatch_path = os.path.join(self.export_sources_folder, "patches/mypatch")
              cmake_path = os.path.join(self.export_sources_folder, "CMakeLists.txt")
              # patching, replacing, happens here

          def build(self):
              # If necessary, the build() method also has access to the export_sources_folder
              # for example if patching happens in build() instead of source()
              cmake_path = os.path.join(self.export_sources_folder, "CMakeLists.txt")


We can see that the ``ConanFile.export_sources_folder`` can provide access to the root folder of the sources:

- Locally it will be the folder where the ``conanfile.py`` lives
- In the cache it will be the "source" folder, that will contain a copy of ``CMakeLists.txt`` and ``patches``,
  while the "source/src" folder will contain the actual downloaded sources.

Example: conanfile in subfolder
-------------------------------

If we have this project, intended to package the code that is in the same repo as the ``conanfile.py``, but
the ``conanfile.py`` is not in the root of the project:

..  code-block:: text

    ├── CMakeLists.txt
    └── conan
        └── conanfile.py


The ``conanfile.py`` would look like this:

..  code-block:: python

      import os
      from conan import ConanFile
      from conan.tools.files import load, copy


      class Pkg(ConanFile):
          name = "pkg"
          version = "0.1"

          def layout(self):
              # The root of the project is one level above
              self.folders.root = ".." 
              # The source of the project (the root CMakeLists.txt) is the source folder
              self.folders.source = "."  
              self.folders.build = "build"
        
          def export_sources(self):
              # The path of the CMakeLists.txt we want to export is one level above
              folder = os.path.join(self.recipe_folder, "..")
              copy(self, "*.txt", folder, self.export_sources_folder)
          
          def source(self):
              # we can see that the CMakeLists.txt is inside the source folder
              cmake = load(self, "CMakeLists.txt")

          def build(self):
              # The build() method can also access the CMakeLists.txt in the source folder
              path = os.path.join(self.source_folder, "CMakeLists.txt")
              cmake = load(self, path)

.. _package_layout_example_multiple_subprojects:

Example: Multiple subprojects
-----------------------------

Lets say that we have a project that contains multiple subprojects, and some of these subprojects need
to access some information that is at their same level (sibling folders). Each subproject would be 
a Conan package.

So we have the following folders and files:

..  code-block:: text

    ├── pkg
    │    ├── conanfile.py
    │    ├── app.cpp  # contains an #include "../common/myheader.h"
    │    └── CMakeLists.txt # contains include(../common/myutils.cmake)
    ├── common
    │    ├── myutils.cmake
    │    └── myheader.h
    └── othersubproject


The ``pkg`` subproject needs to use some of the files located inside the ``common`` folder (that might be
used and shared by other subprojects too), and it references them by their relative location.
Note that ``common`` is not intended to be a Conan package. It is just some common code that will be copied
into the different subproject packages.

We can use the ``self.folders.root = ".."`` layout specifier to locate the root of the project, then
use the ``self.folders.subproject = "subprojectfolder"`` to relocate back most of the layout to the
current subproject folder, as it would be the one containing the build scripts, sources code, etc.,
so other helpers like ``cmake_layout()`` keep working.


..  code-block:: python

    import os
    from conan import ConanFile
    from conan.tools.cmake import cmake_layout, CMake
    from conan.tools.files import load, copy, save

    class Pkg(ConanFile):
        name = "pkg"
        version = "0.1"
        settings = "os", "compiler", "build_type", "arch"
        generators = "CMakeToolchain"

        def layout(self):
            self.folders.root = ".."
            self.folders.subproject = "pkg"
            cmake_layout(self)

        def export_sources(self):
            source_folder = os.path.join(self.recipe_folder, "..")
            copy(self, "*", source_folder, self.export_sources_folder)

        def build(self):
            cmake = CMake(self)
            cmake.configure()
            cmake.build()
            self.run(os.path.join(self.cpp.build.bindirs[0], "myapp"))


Note it is very important the ``export_sources()`` method, that is able to maintain the same relative layout
of the ``pkg`` and ``common`` folders, both in the local developer flow in the current folder, but also
when those sources are copied to the Conan cache, to be built there with ``conan create`` or ``conan install --build=pkg``.
This is one of the design principles of the ``layout()``, the relative location of things must be consistent in the user
folder and in the cache.


Environment variables and configuration
---------------------------------------

There are some packages that might define some environment variables in their
``package_info()`` method via ``self.buildenv_info``, ``self.runenv_info``. Other 
packages can also use ``self.conf_info`` to pass configuration to their consumers.

This is not an issue as long as the value of those environment variables or configuration
do not require using the ``self.package_folder``. If they do, then their values will
not be correct for the "source" and "build" layouts. Something like this will be **broken**
when used in ``editable`` mode:

..  code-block:: python

    import os
    from conan import ConanFile

    class SayConan(ConanFile):
        ...
        def package_info(self):
            # This is BROKEN if we put this package in editable mode
            self.runenv_info.define_path("MYDATA_PATH",
                                         os.path.join(self.package_folder, "my/data/path"))

When the package is in editable mode, for example, ``self.package_folder`` is ``None``, as 
obviously there is no package yet. 
The solution is to define it in the ``layout()`` method, in the same way the ``cpp_info`` can
be defined there:

..  code-block:: python

    from conan import ConanFile

    class SayConan(ConanFile):
        ...
        def layout(self):
            # The final path will be relative to the self.source_folder
            self.layouts.source.buildenv_info.define_path("MYDATA_PATH", "my/source/data/path")
            # The final path will be relative to the self.build_folder
            self.layouts.build.buildenv_info.define_path("MYDATA_PATH2", "my/build/data/path")
            # The final path will be relative to the self.build_folder
            self.layouts.build.conf_info.define_path("MYCONF", "my_conf_folder")


The ``layouts`` object contains ``source``, ``build`` and ``package`` scopes, and each one contains
one instance of ``buildenv_info``, ``runenv_info`` and ``conf_info``.







Before starting
---------------

To understand correctly how the ``layout()`` method can help us we need to recall first how Conan works.

Let's say we are working in a project, using, for example, CMake:

..  code-block:: text

    <my_project_folder>
    ├── conanfile.py
    └── src
        ├── CMakeLists.txt
        ├── hello.cpp
        ├── my_tool.cpp
        └── include
            └── hello.h

When we call ``conan create``, Conan moves the recipe and sources declared in the recipe
to be exported to the local Cache to a recipe folder and after that it will create a
separate package folder to build the binaries and store the actual package contents. Let's
go through the whole process:

1. Conan exports the recipe (conanfile.py) and the declared sources (exports_sources) to the cache. The folders in the
   cache would be something like:

   ..  code-block:: text
        :caption: .conan2/p/<recipe_folder>

        ├── export
        │   └── conanfile.py
        └── export_source
            └── src
                ├── CMakeLists.txt
                ├── hello.cpp
                ├── my_tool.cpp
                └── include
                    └── hello.h

.. note::

    *export*, *export_source*, *source*, *build* and *package* are not the actual names of
    those folders in the Conan cache, we use only the first one or two letters: *e*, *es*,
    *s*, *b* and *p* to prevent problems with long paths but we will use the complete
    names in this tutorial for the sake of clarity


2. If the method ``source()`` exists, it might retrieve sources from the internet. Also,
   the contents of the  ``export_source`` folder are copied to the ``source`` folder.

   ..  code-block:: text
        :caption: .conan2/p/<recipe_folder>

        ├── export
        │   └── conanfile.py
        ├── export_source
        │   └── src
        │       ├── CMakeLists.txt
        │       ├── hello.cpp
        │       ├── my_tool.cpp
        │       └── include
        │           └── hello.h
        └── source
            └── src
                ├── CMakeLists.txt
                ├── hello.cpp
                ├── my_tool.cpp
                └── include
                    └── hello.h

3. Then Conan invokes the ``build()`` method and creates a separate folder to build and
   store the binaries. Conan copies the sources in the build folder and the package
   is built:

   ..  code-block:: text
        :caption: .conan2/p/<recipe_folder>

        ├── export
        │   └── conanfile.py
        ├── export_source
        │   └── src
        │       ├── CMakeLists.txt
        │       ├── hello.cpp
        │       ├── my_tool.cpp
        │       └── include
        │           └── hello.h
        └── source
            └── src
                ├── CMakeLists.txt
                ├── hello.cpp
                ├── my_tool.cpp
                └── include
                    └── hello.h

   ..  code-block:: text
        :caption: .conan2/p/<package_folder>

        └── build
            ├── Release
            │   ├── say.a
            │   └── bin
            │       └── my_app
            └── src
                ├── CMakeLists.txt
                ├── hello.cpp
                ├── my_tool.cpp
                └── include
                    └── hello.h

4. Finally, Conan calls the ``package()`` method to copy the built artifacts from the
   ``source`` (typically includes) and ``build`` folders (libraries and executables) to a
   **package** folder.

   ..  code-block:: text
        :caption: .conan2/p/<recipe_folder>

        ├── export
        │   └── conanfile.py
        ├── export_source
        │   └── src
        │       ├── CMakeLists.txt
        │       ├── hello.cpp
        │       ├── my_tool.cpp
        │       └── include
        │           └── hello.h
        └── source
            └── src
                ├── CMakeLists.txt
                ├── hello.cpp
                ├── my_tool.cpp
                └── include
                    └── hello.h


   ..  code-block:: text
        :caption: .conan2/p/<package_folder>

        ├── build
        │   ├── Release
        │   │   ├── say.a
        │   │   └── bin
        │   │       └── my_app
        │   └── src
        │       ├── CMakeLists.txt
        │       ├── hello.cpp
        │       ├── my_tool.cpp
        │       └── include
        │           └── hello.h
        └── package
            ├── lib
            │   └── say.a
            ├── bin
            │   └── my_app
            └── include
                └── hello.h

5. The ``package_info(self)`` method will describe with the ``self.cpp_info`` object the contents of the ``package``
   folder, that is the one the consumers use to link against it.


   ..  code-block:: python
       :caption: conanfile.py

       import os
       from conan import ConanFile
       from conan.tools.cmake import CMake


       class SayConan(ConanFile):
           name = "say"
           version = "0.1"
           exports_sources = "src/*"
           ...
           def package_info(self):
               # These are default values and doesn't need to be adjusted
               self.cpp_info.includedirs = ["include"]
               self.cpp_info.libdirs = ["lib"]
               self.cpp_info.bindirs = ["bin"]

               # The library name
               self.cpp_info.libs = ["say"]


So, just as we describe the package folder in the ``package_info()`` method, we can use
``layout()`` to describe the ``source`` and ``build`` folders (both in a local project and
in the cache):

  - We can run the conan local commands (**conan source**, **conan build**, **conan
    export-pkg**) without taking care of specifying directories, always with the same
    syntax.
  - If you are using an IDE, you can describe the build folder naming in the layout, so
    the libraries and executables are always in a known place.
  - In the cache, the layout (like a build subfolder) is kept, so we can always know where
    the artifacts are before packaging them.
  - It enables tools like the :ref:`AutoPackager<conan_tools_files_packaging>` to automate
    the **package()** method.
  - It enables to use :ref:`editable packages<editable_packages>`, because the recipe
    describes where the contents will be, even for different configurations, so the
    consumers can link with the correct built artifacts.


.. seealso::

    Read more about the ConanFile attributes you can set in the layout() method in the
    :ref:`conanfile.py attributes <conan_conanfile_attributes>` documentation.


